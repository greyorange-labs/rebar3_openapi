%%%-------------------------------------------------------------------
%%% @doc Transform generated openapi-generator code to hybrid pattern
%%% Converts generated router and handlers to trails-compatible format
%%% @end
%%%-------------------------------------------------------------------
-module(rebar3_openapi_transformer).

-export([
    transform/1,
    generate_router/4,
    generate_handler/2,
    generate_logic_handler/2
]).

%%%===================================================================
%%% API
%%%===================================================================

%% @doc Transform generated code to hybrid pattern
-spec transform(map()) -> ok | {error, term()}.
transform(Opts) ->
    try
        _TempDir = maps:get(temp_dir, Opts),  % Reserved for future use with openapi-generator parsing
        OutputDir = maps:get(output_dir, Opts),
        Handler = maps:get(handler, Opts),
        LogicModule = maps:get(logic_module, Opts),
        Spec = maps:get(spec, Opts),
        Update = maps:get(update, Opts, false),

        rebar3_openapi_utils:ensure_dir(OutputDir),

        %% Extract operations from spec
        Operations = rebar3_openapi_parser:get_operations(Spec),
        Paths = rebar3_openapi_parser:get_paths(Spec),

        %% Generate router module with trails() wrapper
        BaseHandlerName = case lists:suffix("_handler", Handler) of
            true ->
                Len = length(Handler) - length("_handler"),
                lists:sublist(Handler, Len);
            false ->
                Handler
        end,
        RouterModule = BaseHandlerName ++ "_router",

        %% Logic module is already correctly named by caller
        ActualLogicModule = LogicModule,

        RouterFile = filename:join(OutputDir, RouterModule ++ ".erl"),
        RouterContent = generate_router(RouterModule, Handler, ActualLogicModule, #{
            operations => Operations,
            paths => Paths
        }),
        write_if_allowed(RouterFile, RouterContent, Opts),

        %% Generate or update handler module
        HandlerFile = filename:join(OutputDir, Handler ++ ".erl"),
        case Update andalso filelib:is_file(HandlerFile) of
            true ->
                rebar3_openapi_utils:info("Updating existing handler: ~s", [Handler]),
                update_handler(HandlerFile, Operations, Opts);
            false ->
                rebar3_openapi_utils:info("Generating new handler: ~s", [Handler]),
                HandlerContent = generate_handler(Handler, #{
                    operations => Operations,
                    paths => Paths,
                    logic_module => LogicModule,
                    spec => Spec
                }),
                write_if_allowed(HandlerFile, HandlerContent, Opts)
        end,

        %% Generate logic handler skeleton (only if not exists)
        LogicFile = filename:join(OutputDir, ActualLogicModule ++ ".erl"),
        case filelib:is_file(LogicFile) of
            true ->
                rebar3_openapi_utils:info("Logic handler already exists, skipping: ~s", [ActualLogicModule]);
            false ->
                rebar3_openapi_utils:info("Generating logic handler skeleton: ~s", [ActualLogicModule]),
                LogicContent = generate_logic_handler(ActualLogicModule, #{
                    operations => Operations,
                    handler => Handler,
                    spec => Spec
                }),
                write_if_allowed(LogicFile, LogicContent, Opts)
        end,

        %% Generate JSON schemas for validation
        TempDir = maps:get(temp_dir, Opts, undefined),
        generate_schemas(OutputDir, Spec, TempDir, Opts),

        ok
    catch
        throw:Error ->
            {error, Error};
        _:Error:Stack ->
            rebar3_openapi_utils:error("Transformation failed: ~p", [Error]),
            rebar3_openapi_utils:debug("Stack: ~p", [Stack]),
            {error, Error}
    end.

%% @doc Generate router module with trails() compatibility
-spec generate_router(string(), string(), string(), map()) -> iolist().
generate_router(RouterModule, Handler, LogicModule, Opts) ->
    Operations = maps:get(operations, Opts),

    %% Group operations by path
    PathOps = group_operations_by_path(Operations),

    %% Generate module
    [
        "%%%-------------------------------------------------------------------\n",
        "%%% @doc Router module for ", Handler, "\n",
        "%%% Generated by rebar3_openapi\n",
        "%%% Provides trails() compatibility wrapper\n",
        "%%% @end\n",
        "%%%-------------------------------------------------------------------\n",
        "-module(", RouterModule, ").\n\n",

        "%% API exports\n",
        "-export([trails/0, get_paths/1, get_operations/0]).\n\n",

        "%% Behavior for trails compatibility\n",
        "-behaviour(trails_handler).\n\n",

        "%%%===================================================================\n",
        "%%% API - Trails Compatibility\n",
        "%%%===================================================================\n\n",

        "%% @doc Returns trails for cowboy_routes_manager\n",
        "trails() ->\n",
        "    Paths = get_paths(", LogicModule, "),\n",
        "    lists:flatten([PathList || {'_', PathList} <- Paths]).\n\n",

        "%% @doc Get paths with handler module\n",
        "get_paths(LogicModule) ->\n",
        "    [{'_', [\n",
        generate_path_entries(PathOps, Handler, LogicModule),
        "    ]}].\n\n",

        "%% @doc Get all operations metadata\n",
        "get_operations() ->\n",
        "    [\n",
        generate_operations_list(Operations),
        "    ].\n"
    ].

%% @doc Generate handler module
-spec generate_handler(string(), map()) -> iolist().
generate_handler(Handler, Opts) ->
    Operations = maps:get(operations, Opts),
    _LogicModule = maps:get(logic_module, Opts),  % Used in generated code

    %% Group operations by path and method
    _PathOps = group_operations_by_path(Operations),  % Reserved for future advanced routing
    AllMethods = get_all_methods(Operations),

    [
        "%%%-------------------------------------------------------------------\n",
        "%%% @doc HTTP handler for ", Handler, "\n",
        "%%% Generated by rebar3_openapi\n",
        "%%% @end\n",
        "%%%-------------------------------------------------------------------\n",
        "-module(", Handler, ").\n\n",

        "-behaviour(cowboy_rest).\n\n",

        "%% Cowboy REST callbacks\n",
        "-export([\n",
        "    init/2,\n",
        "    allowed_methods/2,\n",
        "    content_types_accepted/2,\n",
        "    content_types_provided/2,\n",
        "    handle_json_accepted/2,\n",
        "    handle_json_provided/2\n",
        "]).\n\n",

        "%%%===================================================================\n",
        "%%% Cowboy REST Callbacks\n",
        "%%%===================================================================\n\n",

        "init(Req, {OperationId, Method, LogicModule}) ->\n",
        "    %% Store method in context during init\n",
        "    Context = #{operation => OperationId, method => Method, logic_module => LogicModule},\n",
        "    {cowboy_rest, Req, Context}.\n\n",

        "allowed_methods(Req, #{method := Method} = Context) ->\n",
        "    %% Return path-specific allowed methods from context\n",
        "    {[Method], Req, Context}.\n\n",

        "content_types_accepted(Req, Context) ->\n",
        "    {[{{<<\"application\">>, <<\"json\">>, '*'}, handle_json_accepted}], Req, Context}.\n\n",

        "content_types_provided(Req, Context) ->\n",
        "    {[{{<<\"application\">>, <<\"json\">>, '*'}, handle_json_provided}], Req, Context}.\n\n",

        "handle_json_accepted(Req, #{operation := OpId, logic_module := LogicModule} = Context) ->\n",
        "    %% Delegate to logic handler\n",
        "    case LogicModule:accept_callback(default, OpId, Req, Context) of\n",
        "        {ok, StatusCode, Headers, Body, Req2, Context2} ->\n",
        "            %% Build and send response\n",
        "            Req3 = cowboy_req:reply(StatusCode, Headers, Body, Req2),\n",
        "            {stop, Req3, Context2};\n",
        "        {error, StatusCode, Headers, Body, Req2, Context2} ->\n",
        "            %% Build and send error response\n",
        "            Req3 = cowboy_req:reply(StatusCode, Headers, Body, Req2),\n",
        "            {stop, Req3, Context2}\n",
        "    end.\n\n",

        "handle_json_provided(Req, #{operation := OpId, logic_module := LogicModule} = Context) ->\n",
        "    %% Delegate to logic handler\n",
        "    case LogicModule:provide_callback(default, OpId, Req, Context) of\n",
        "        {ok, StatusCode, Headers, Body, Req2, Context2} ->\n",
        "            %% Build and send response\n",
        "            Req3 = cowboy_req:reply(StatusCode, Headers, Body, Req2),\n",
        "            {stop, Req3, Context2};\n",
        "        {error, StatusCode, Headers, Body, Req2, Context2} ->\n",
        "            %% Build and send error response\n",
        "            Req3 = cowboy_req:reply(StatusCode, Headers, Body, Req2),\n",
        "            {stop, Req3, Context2}\n",
        "    end.\n\n",

        "%%%===================================================================\n",
        "%%% Internal Functions\n",
        "%%%===================================================================\n\n"
    ].

%% @doc Generate logic handler skeleton
-spec generate_logic_handler(string(), map()) -> iolist().
generate_logic_handler(LogicModule, Opts) ->
    Operations = maps:get(operations, Opts),
    Handler = maps:get(handler, Opts, ""),

    %% Separate operations by HTTP method
    {GetOps, MutateOps} = lists:partition(
        fun({_Path, Method, _Op}) ->
            Method =:= <<"get">> orelse Method =:= <<"head">>
        end,
        Operations
    ),

    [
        "%%%-------------------------------------------------------------------\n",
        "%%% @doc Logic handler for business logic\n",
        "%%% Implement your business logic callbacks here\n",
        "%%% Generated by rebar3_openapi - IMPLEMENT YOUR LOGIC\n",
        "%%% @end\n",
        "%%%-------------------------------------------------------------------\n",
        "-module(", LogicModule, ").\n\n",

        "%% API exports\n",
        "-export([\n",
        "    provide_callback/4,\n",
        "    accept_callback/4,\n",
        "    get_schema/1\n",
        "]).\n\n",

        "%%%===================================================================\n",
        "%%% Schema Loader Helper\n",
        "%%%===================================================================\n\n",
        "%% @doc Load JSON schema for validation\n",
        "%% Schemas are located in priv/schemas/", Handler, "/ directory\n",
        "%% Example: get_schema('ErrorResponse') or get_schema(\"ErrorResponse\")\n",
        "get_schema(SchemaName) when is_atom(SchemaName) ->\n",
        "    get_schema(atom_to_list(SchemaName));\n",
        "get_schema(SchemaName) when is_list(SchemaName) ->\n",
        "    PrivDir = code:priv_dir(", Handler, "_app),  %% Adjust to your app name\n",
        "    SchemaFile = filename:join([PrivDir, \"schemas\", \"", Handler, "\", SchemaName ++ \".json\"]),\n",
        "    case file:read_file(SchemaFile) of\n",
        "        {ok, SchemaBin} -> jsx:decode(SchemaBin, [return_maps]);\n",
        "        {error, Reason} -> error({schema_not_found, SchemaName, Reason})\n",
        "    end.\n\n",
        "%%%===================================================================\n",
        "%%% API - Provide Callbacks (GET, HEAD)\n",
        "%%%===================================================================\n\n",

        generate_provide_callbacks(GetOps),
        "\n",

        "%%%===================================================================\n",
        "%%% API - Accept Callbacks (POST, PUT, DELETE, PATCH)\n",
        "%%%===================================================================\n\n",

        generate_accept_callbacks(MutateOps),
        "\n",

        "%%%===================================================================\n",
        "%%% Fallback\n",
        "%%%===================================================================\n\n",

        "provide_callback(_Class, OperationId, Req, Context) ->\n",
        "    rebar3_openapi_utils:warn(\"Unimplemented operation: ~p\", [OperationId]),\n",
        "    ErrorBody = jsx:encode(#{error => <<\"not_implemented\">>}),\n",
        "    {error, 501, #{<<\"content-type\">> => <<\"application/json\">>}, ErrorBody, Req, Context}.\n\n",

        "accept_callback(_Class, OperationId, Req, Context) ->\n",
        "    rebar3_openapi_utils:warn(\"Unimplemented operation: ~p\", [OperationId]),\n",
        "    ErrorBody = jsx:encode(#{error => <<\"not_implemented\">>}),\n",
        "    {error, 501, #{<<\"content-type\">> => <<\"application/json\">>}, ErrorBody, Req, Context}.\n"

    ].

%%%===================================================================
%%% Internal Functions - Code Generation Helpers
%%%===================================================================

-spec group_operations_by_path([{binary(), binary(), map()}]) -> [{binary(), [{binary(), map()}]}].
group_operations_by_path(Operations) ->
    Grouped = lists:foldl(
        fun({Path, Method, Op}, Acc) ->
            maps:update_with(
                Path,
                fun(Methods) -> [{Method, Op} | Methods] end,
                [{Method, Op}],
                Acc
            )
        end,
        #{},
        Operations
    ),
    maps:to_list(Grouped).

-spec get_all_methods([{binary(), binary(), map()}]) -> [binary()].
get_all_methods(Operations) ->
    Methods = lists:usort([Method || {_Path, Method, _Op} <- Operations]),
    lists:map(fun(M) -> string:uppercase(binary_to_list(M)) end, Methods).

-spec generate_path_entries([{binary(), [{binary(), map()}]}], string(), string()) -> iolist().
generate_path_entries(PathOps, Handler, LogicModule) ->
    AllEntries = lists:flatten(lists:map(
        fun({Path, Methods}) ->
            lists:map(
                fun({Method, Op}) ->
                    OpId = maps:get(<<"operationId">>, Op, <<"unknown">>),
                    MethodUpper = string:uppercase(binary_to_list(Method)),
                    {Path, OpId, MethodUpper}
                end,
                Methods
            )
        end,
        PathOps
    )),
    string:join(
        lists:map(
            fun({Path, OpId, MethodUpper}) ->
                io_lib:format("        {<<\"~s\">>, ~s, {'~s', <<\"~s\">>, ~s}}",
                             [Path, Handler, OpId, MethodUpper, LogicModule])
            end,
            AllEntries
        ),
        ",\n"
    ) ++ "\n".

-spec generate_operations_list([{binary(), binary(), map()}]) -> iolist().
generate_operations_list(Operations) ->
    string:join(
        lists:map(
            fun({Path, Method, Op}) ->
                OpId = maps:get(<<"operationId">>, Op, <<"unknown">>),
                io_lib:format("        {~p, ~p, '~s'}", [Path, Method, OpId])
            end,
            Operations
        ),
        ",\n"
    ).

-spec generate_allowed_methods_list([string()]) -> iolist().
generate_allowed_methods_list(Methods) ->
    "[" ++ string:join([io_lib:format("<<\"~s\">>", [M]) || M <- Methods], ", ") ++ "]".

-spec generate_provide_callbacks([{binary(), binary(), map()}]) -> iolist().
generate_provide_callbacks([]) ->
    "%% No GET/HEAD operations\n";
generate_provide_callbacks(Operations) ->
    lists:map(
        fun({Path, _Method, Op}) ->
            OpId = maps:get(<<"operationId">>, Op, <<"unknown">>),
            Summary = maps:get(<<"summary">>, Op, <<"No description">>),
            [
                "%% @doc ", Summary, "\n",
                "%% Path: ", Path, "\n",
                "provide_callback(_Class, '", OpId, "', Req, Context) ->\n",
                "    %% TODO: Implement business logic\n",
                "    %% Example: Call your controller function here\n",
                "    %% Result = your_controller:handle_", OpId, "(Req),\n",
                "    %% ResponseBody = jsx:encode(Result),\n",
                "    ResponseBody = jsx:encode(#{message => <<\"Not implemented\">>}),\n",
                "    Headers = #{<<\"content-type\">> => <<\"application/json\">>},\n",
                "    {ok, 200, Headers, ResponseBody, Req, Context};\n\n"
            ]
        end,
        Operations
    ).

-spec generate_accept_callbacks([{binary(), binary(), map()}]) -> iolist().
generate_accept_callbacks([]) ->
    "%% No POST/PUT/DELETE/PATCH operations\n";
generate_accept_callbacks(Operations) ->
    lists:map(
        fun({Path, Method, Op}) ->
            OpId = maps:get(<<"operationId">>, Op, <<"unknown">>),
            Summary = maps:get(<<"summary">>, Op, <<"No description">>),
            StatusCode = case Method of
                <<"post">> -> "201";  % Created
                <<"delete">> -> "204";  % No Content
                _ -> "200"  % OK for PUT, PATCH
            end,
            [
                "%% @doc ", Summary, "\n",
                "%% Path: ", Path, " (", string:uppercase(binary_to_list(Method)), ")\n",
                "accept_callback(_Class, '", OpId, "', Req, Context) ->\n",
                "    %% TODO: Implement business logic\n",
                "    %% Example: Parse request body and call your controller\n",
                "    %% {ok, Body, Req2} = cowboy_req:read_body(Req),\n",
                "    %% RequestData = jsx:decode(Body, [return_maps]),\n",
                "    %% Validate request\n",
                "    %% case jesse:validate_with_schema(get_schema('", OpId, "_request'), RequestData) of\n",
                "    %%     {ok, ValidData} -> \n",
                "    %%         Result = your_controller:handle_", OpId, "(ValidData),\n",
                "    %%         ResponseBody = jsx:encode(Result),\n",
                "    %%         {ok, ", StatusCode, ", Headers, ResponseBody, Req2, Context};\n",
                "    %%     {error, ValidationErrors} ->\n",
                "    %%         ErrorBody = jsx:encode(#{error => <<\"validation_failed\">>, details => ValidationErrors}),\n",
                "    %%         {error, 400, Headers, ErrorBody, Req2, Context}\n",
                "    %% end.\n",
                "    ResponseBody = jsx:encode(#{message => <<\"Not implemented\">>}),\n",
                "    Headers = #{<<\"content-type\">> => <<\"application/json\">>},\n",
                "    {ok, ", StatusCode, ", Headers, ResponseBody, Req, Context};\n\n"
            ]
        end,
        Operations
    ).

-spec update_handler(file:filename(), [{binary(), binary(), map()}], map()) -> ok.
update_handler(HandlerFile, Operations, _Opts) ->
    %% For now, just log that we would update
    %% Full AST parsing and modification would go here
    rebar3_openapi_utils:info("Updating handler: ~s", [HandlerFile]),
    rebar3_openapi_utils:info("New operations detected: ~p", [length(Operations)]),
    rebar3_openapi_utils:warn("Handler update mode not fully implemented - manual merge required", []),
    ok.

-spec write_if_allowed(file:filename(), iolist(), map()) -> ok.
write_if_allowed(File, Content, Opts) ->
    Force = maps:get(force, Opts, false),

    case filelib:is_file(File) andalso not Force of
        true ->
            rebar3_openapi_utils:warn("File exists, skipping (use --force to overwrite): ~s", [File]),
            ok;
        false ->
            rebar3_openapi_utils:write_file(File, Content),
            rebar3_openapi_utils:info("Generated: ~s", [File]),
            ok
    end.

-spec generate_schemas(file:filename(), map(), file:filename(), map()) -> ok.
generate_schemas(OutputDir, Spec, TempDir, Opts) ->
    try
        Handler = maps:get(handler, Opts, "handler"),

        %% Create priv/ directory
        PrivDir = filename:join(OutputDir, "priv"),
        rebar3_openapi_utils:ensure_dir(filename:join(PrivDir, "dummy")),

        %% Copy and rename openapi.json to {handler}_openapi.json
        SourceOpenAPIJson = filename:join([TempDir, "priv", "openapi.json"]),
        DestOpenAPIJson = filename:join(PrivDir, Handler ++ "_openapi.json"),
        case filelib:is_file(SourceOpenAPIJson) of
            true ->
                {ok, _} = file:copy(SourceOpenAPIJson, DestOpenAPIJson),
                rebar3_openapi_utils:info("Copied OpenAPI spec to: ~s", [DestOpenAPIJson]);
            false ->
                rebar3_openapi_utils:warn("OpenAPI JSON not found in temp dir: ~s", [SourceOpenAPIJson])
        end,

        %% Create handler-specific schemas directory: priv/schemas/{handler}/
        HandlerSchemasDir = filename:join([PrivDir, "schemas", Handler]),
        rebar3_openapi_utils:ensure_dir(filename:join(HandlerSchemasDir, "dummy")),

        %% Extract and generate individual schema files for Jesse validation
        Schemas = maps:get(<<"components">>, Spec, #{}),
        ComponentSchemas = maps:get(<<"schemas">>, Schemas, #{}),

        case maps:size(ComponentSchemas) of
            0 ->
                rebar3_openapi_utils:info("No schemas to generate", []);
            Count ->
                rebar3_openapi_utils:info("Generating ~p schema files in ~s", [Count, HandlerSchemasDir]),
                maps:foreach(
                    fun(SchemaName, SchemaData) ->
                        FileName = binary_to_list(SchemaName) ++ ".json",
                        FilePath = filename:join(HandlerSchemasDir, FileName),
                        SchemaJson = jsx:encode(SchemaData, [{space, 2}, {indent, 2}]),
                        ok = file:write_file(FilePath, SchemaJson),
                        rebar3_openapi_utils:debug("Generated schema: ~s", [FilePath])
                    end,
                    ComponentSchemas
                )
        end,

        ok
    catch
        _:SchemaError:SchemaStack ->
            rebar3_openapi_utils:warn("Schema generation failed: ~p", [SchemaError]),
            rebar3_openapi_utils:debug("Stack: ~p", [SchemaStack]),
            ok  % Don't fail transformation if schema generation fails
    end.

