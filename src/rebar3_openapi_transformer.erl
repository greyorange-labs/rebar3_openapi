%%%-------------------------------------------------------------------
%%% @doc Transform generated openapi-generator code to hybrid pattern
%%% Converts generated router and handlers to trails-compatible format
%%% @end
%%%-------------------------------------------------------------------
-module(rebar3_openapi_transformer).

-export([
    transform/1,
    generate_router/2,
    generate_handler/2,
    generate_logic_handler/2
]).

%%%===================================================================
%%% API
%%%===================================================================

%% @doc Transform generated code to hybrid pattern
-spec transform(map()) -> ok | {error, term()}.
transform(Opts) ->
    try
        _TempDir = maps:get(temp_dir, Opts),  % Reserved for future use with openapi-generator parsing
        OutputDir = maps:get(output_dir, Opts),
        Handler = maps:get(handler, Opts),
        LogicModule = maps:get(logic_module, Opts),
        Spec = maps:get(spec, Opts),
        Update = maps:get(update, Opts, false),

        rebar3_openapi_utils:ensure_dir(OutputDir),

        %% Extract operations from spec
        Operations = rebar3_openapi_parser:get_operations(Spec),
        Paths = rebar3_openapi_parser:get_paths(Spec),

        %% Generate router module with trails() wrapper
        RouterFile = filename:join(OutputDir, Handler ++ "_router.erl"),
        RouterContent = generate_router(Handler, #{
            operations => Operations,
            paths => Paths,
            logic_module => LogicModule
        }),
        write_if_allowed(RouterFile, RouterContent, Opts),

        %% Generate or update handler module
        HandlerFile = filename:join(OutputDir, Handler ++ ".erl"),
        case Update andalso filelib:is_file(HandlerFile) of
            true ->
                rebar3_openapi_utils:info("Updating existing handler: ~s", [Handler]),
                update_handler(HandlerFile, Operations, Opts);
            false ->
                rebar3_openapi_utils:info("Generating new handler: ~s", [Handler]),
                HandlerContent = generate_handler(Handler, #{
                    operations => Operations,
                    paths => Paths,
                    logic_module => LogicModule,
                    spec => Spec
                }),
                write_if_allowed(HandlerFile, HandlerContent, Opts)
        end,

        %% Generate logic handler skeleton (only if not exists)
        LogicFile = filename:join(OutputDir, LogicModule ++ ".erl"),
        case filelib:is_file(LogicFile) of
            true ->
                rebar3_openapi_utils:info("Logic handler already exists, skipping: ~s", [LogicModule]);
            false ->
                rebar3_openapi_utils:info("Generating logic handler skeleton: ~s", [LogicModule]),
                LogicContent = generate_logic_handler(LogicModule, #{
                    operations => Operations,
                    handler => Handler
                }),
                write_if_allowed(LogicFile, LogicContent, Opts)
        end,

        ok
    catch
        throw:Error ->
            {error, Error};
        _:Error:Stack ->
            rebar3_openapi_utils:error("Transformation failed: ~p", [Error]),
            rebar3_openapi_utils:debug("Stack: ~p", [Stack]),
            {error, Error}
    end.

%% @doc Generate router module with trails() compatibility
-spec generate_router(string(), map()) -> iolist().
generate_router(Handler, Opts) ->
    Operations = maps:get(operations, Opts),
    LogicModule = maps:get(logic_module, Opts),

    %% Group operations by path
    PathOps = group_operations_by_path(Operations),

    %% Generate module
    [
        "%%%-------------------------------------------------------------------\n",
        "%%% @doc Router module for ", Handler, "\n",
        "%%% Generated by rebar3_openapi\n",
        "%%% Provides trails() compatibility wrapper\n",
        "%%% @end\n",
        "%%%-------------------------------------------------------------------\n",
        "-module(", Handler, "_router).\n\n",

        "%% API exports\n",
        "-export([trails/0, get_paths/1, get_operations/0]).\n\n",

        "%% Behavior for trails compatibility\n",
        "-behaviour(trails_handler).\n\n",

        "%%%===================================================================\n",
        "%%% API - Trails Compatibility\n",
        "%%%===================================================================\n\n",

        "%% @doc Returns trails for cowboy_routes_manager\n",
        "trails() ->\n",
        "    Paths = get_paths(", LogicModule, "),\n",
        "    lists:flatten([PathList || {'_', PathList} <- Paths]).\n\n",

        "%% @doc Get paths with handler module\n",
        "get_paths(LogicModule) ->\n",
        "    [{'_', [\n",
        generate_path_entries(PathOps, Handler),
        "    ]}].\n\n",

        "%% @doc Get all operations metadata\n",
        "get_operations() ->\n",
        "    [\n",
        generate_operations_list(Operations),
        "    ].\n"
    ].

%% @doc Generate handler module
-spec generate_handler(string(), map()) -> iolist().
generate_handler(Handler, Opts) ->
    Operations = maps:get(operations, Opts),
    _LogicModule = maps:get(logic_module, Opts),  % Used in generated code

    %% Group operations by path and method
    _PathOps = group_operations_by_path(Operations),  % Reserved for future advanced routing
    AllMethods = get_all_methods(Operations),

    [
        "%%%-------------------------------------------------------------------\n",
        "%%% @doc HTTP handler for ", Handler, "\n",
        "%%% Generated by rebar3_openapi\n",
        "%%% @end\n",
        "%%%-------------------------------------------------------------------\n",
        "-module(", Handler, ").\n\n",

        "-behaviour(cowboy_rest).\n\n",

        "%% Cowboy REST callbacks\n",
        "-export([\n",
        "    init/2,\n",
        "    allowed_methods/2,\n",
        "    content_types_accepted/2,\n",
        "    content_types_provided/2,\n",
        "    handle_json_accepted/2,\n",
        "    handle_json_provided/2\n",
        "]).\n\n",

        "%%%===================================================================\n",
        "%%% Cowboy REST Callbacks\n",
        "%%%===================================================================\n\n",

        "init(Req, {Operations, LogicModule}) ->\n",
        "    %% Extract operation ID from route opts\n",
        "    OperationId = case Operations of\n",
        "        [Op] -> Op;  % Single operation\n",
        "        Ops -> determine_operation(Req, Ops)\n",
        "    end,\n",
        "    Context = #{operation => OperationId, logic_module => LogicModule},\n",
        "    {cowboy_rest, Req, Context}.\n\n",

        "allowed_methods(Req, Context) ->\n",
        "    Methods = ", generate_allowed_methods_list(AllMethods), ",\n",
        "    {Methods, Req, Context}.\n\n",

        "content_types_accepted(Req, Context) ->\n",
        "    {[{{<<\"application\">>, <<\"json\">>, '*'}, handle_json_accepted}], Req, Context}.\n\n",

        "content_types_provided(Req, Context) ->\n",
        "    {[{{<<\"application\">>, <<\"json\">>, '*'}, handle_json_provided}], Req, Context}.\n\n",

        "handle_json_accepted(Req, #{operation := OpId, logic_module := LogicModule} = Context) ->\n",
        "    %% Delegate to logic handler\n",
        "    case LogicModule:accept_callback(default, OpId, Req, Context) of\n",
        "        {ok, Req2, Context2} ->\n",
        "            {true, Req2, Context2};\n",
        "        {error, Reason, Req2, Context2} ->\n",
        "            rebar3_openapi_utils:error(\"Accept callback failed: ~p\", [Reason]),\n",
        "            {false, Req2, Context2}\n",
        "    end.\n\n",

        "handle_json_provided(Req, #{operation := OpId, logic_module := LogicModule} = Context) ->\n",
        "    %% Delegate to logic handler\n",
        "    case LogicModule:provide_callback(default, OpId, Req, Context) of\n",
        "        {ok, Body, Req2, Context2} ->\n",
        "            {jsx:encode(Body), Req2, Context2};\n",
        "        {error, Reason, Req2, Context2} ->\n",
        "            rebar3_openapi_utils:error(\"Provide callback failed: ~p\", [Reason]),\n",
        "            {<<\"{\\\"error\\\": \\\"internal_error\\\"}\">>, Req2, Context2}\n",
        "    end.\n\n",

        "%%%===================================================================\n",
        "%%% Internal Functions\n",
        "%%%===================================================================\n\n",

        "determine_operation(Req, Operations) ->\n",
        "    Method = cowboy_req:method(Req),\n",
        "    %% Map HTTP method to operation ID\n",
        "    %% This is a simplified version - enhance based on your needs\n",
        "    hd(Operations).\n"
    ].

%% @doc Generate logic handler skeleton
-spec generate_logic_handler(string(), map()) -> iolist().
generate_logic_handler(LogicModule, Opts) ->
    Operations = maps:get(operations, Opts),

    %% Separate operations by HTTP method
    {GetOps, MutateOps} = lists:partition(
        fun({_Path, Method, _Op}) ->
            Method =:= <<"get">> orelse Method =:= <<"head">>
        end,
        Operations
    ),

    [
        "%%%-------------------------------------------------------------------\n",
        "%%% @doc Logic handler for business logic\n",
        "%%% Implement your business logic callbacks here\n",
        "%%% Generated by rebar3_openapi - IMPLEMENT YOUR LOGIC\n",
        "%%% @end\n",
        "%%%-------------------------------------------------------------------\n",
        "-module(", LogicModule, ").\n\n",

        "%% API exports\n",
        "-export([\n",
        "    provide_callback/4,\n",
        "    accept_callback/4\n",
        "]).\n\n",

        "%%%===================================================================\n",
        "%%% API - Provide Callbacks (GET, HEAD)\n",
        "%%%===================================================================\n\n",

        generate_provide_callbacks(GetOps),
        "\n",

        "%%%===================================================================\n",
        "%%% API - Accept Callbacks (POST, PUT, DELETE, PATCH)\n",
        "%%%===================================================================\n\n",

        generate_accept_callbacks(MutateOps),
        "\n",

        "%%%===================================================================\n",
        "%%% Fallback\n",
        "%%%===================================================================\n\n",

        "provide_callback(_Class, OperationId, Req, Context) ->\n",
        "    rebar3_openapi_utils:warn(\"Unimplemented operation: ~p\", [OperationId]),\n",
        "    {error, not_implemented, Req, Context}.\n\n",

        "accept_callback(_Class, OperationId, Req, Context) ->\n",
        "    rebar3_openapi_utils:warn(\"Unimplemented operation: ~p\", [OperationId]),\n",
        "    {error, not_implemented, Req, Context}.\n"
    ].

%%%===================================================================
%%% Internal Functions - Code Generation Helpers
%%%===================================================================

-spec group_operations_by_path([{binary(), binary(), map()}]) -> [{binary(), [{binary(), map()}]}].
group_operations_by_path(Operations) ->
    Grouped = lists:foldl(
        fun({Path, Method, Op}, Acc) ->
            maps:update_with(
                Path,
                fun(Methods) -> [{Method, Op} | Methods] end,
                [{Method, Op}],
                Acc
            )
        end,
        #{},
        Operations
    ),
    maps:to_list(Grouped).

-spec get_all_methods([{binary(), binary(), map()}]) -> [binary()].
get_all_methods(Operations) ->
    Methods = lists:usort([Method || {_Path, Method, _Op} <- Operations]),
    lists:map(fun(M) -> string:uppercase(binary_to_list(M)) end, Methods).

-spec generate_path_entries([{binary(), [{binary(), map()}]}], string()) -> iolist().
generate_path_entries(PathOps, Handler) ->
    lists:map(
        fun({Path, Methods}) ->
            OperationIds = [maps:get(<<"operationId">>, Op, <<"unknown">>)
                           || {_Method, Op} <- Methods],
            [
                "        {<<\"", Path, "\">>, ", Handler, ", {",
                string:join([io_lib:format("'~s'", [OpId]) || OpId <- OperationIds], ", "),
                ", ", Handler, "_logic_handler}}",
                case PathOps of
                    [_] -> "\n";
                    _ -> ",\n"
                end
            ]
        end,
        PathOps
    ).

-spec generate_operations_list([{binary(), binary(), map()}]) -> iolist().
generate_operations_list(Operations) ->
    string:join(
        lists:map(
            fun({Path, Method, Op}) ->
                OpId = maps:get(<<"operationId">>, Op, <<"unknown">>),
                io_lib:format("        {~p, ~p, '~s'}", [Path, Method, OpId])
            end,
            Operations
        ),
        ",\n"
    ).

-spec generate_allowed_methods_list([string()]) -> iolist().
generate_allowed_methods_list(Methods) ->
    "[" ++ string:join([io_lib:format("<<\"~s\">>", [M]) || M <- Methods], ", ") ++ "]".

-spec generate_provide_callbacks([{binary(), binary(), map()}]) -> iolist().
generate_provide_callbacks([]) ->
    "%% No GET/HEAD operations\n";
generate_provide_callbacks(Operations) ->
    lists:map(
        fun({Path, _Method, Op}) ->
            OpId = maps:get(<<"operationId">>, Op, <<"unknown">>),
            Summary = maps:get(<<"summary">>, Op, <<"No description">>),
            [
                "%% @doc ", Summary, "\n",
                "%% Path: ", Path, "\n",
                "provide_callback(_Class, '", OpId, "', Req, Context) ->\n",
                "    %% TODO: Implement business logic\n",
                "    %% Example: Call your controller function here\n",
                "    %% {Code, RespBody} = your_controller:handle_", OpId, "(),\n",
                "    Response = #{message => <<\"Not implemented\">>},\n",
                "    {ok, Response, Req, Context};\n\n"
            ]
        end,
        Operations
    ).

-spec generate_accept_callbacks([{binary(), binary(), map()}]) -> iolist().
generate_accept_callbacks([]) ->
    "%% No POST/PUT/DELETE/PATCH operations\n";
generate_accept_callbacks(Operations) ->
    lists:map(
        fun({Path, Method, Op}) ->
            OpId = maps:get(<<"operationId">>, Op, <<"unknown">>),
            Summary = maps:get(<<"summary">>, Op, <<"No description">>),
            [
                "%% @doc ", Summary, "\n",
                "%% Path: ", Path, " (", string:uppercase(binary_to_list(Method)), ")\n",
                "accept_callback(_Class, '", OpId, "', Req, Context) ->\n",
                "    %% TODO: Implement business logic\n",
                "    %% Example: Parse request body and call your controller\n",
                "    %% {ok, Body, Req2} = cowboy_req:read_body(Req),\n",
                "    %% RequestData = jsx:decode(Body, [return_maps]),\n",
                "    %% Result = your_controller:handle_", OpId, "(RequestData),\n",
                "    {ok, Req, Context};\n\n"
            ]
        end,
        Operations
    ).

-spec update_handler(file:filename(), [{binary(), binary(), map()}], map()) -> ok.
update_handler(HandlerFile, Operations, _Opts) ->
    %% For now, just log that we would update
    %% Full AST parsing and modification would go here
    rebar3_openapi_utils:info("Updating handler: ~s", [HandlerFile]),
    rebar3_openapi_utils:info("New operations detected: ~p", [length(Operations)]),
    rebar3_openapi_utils:warn("Handler update mode not fully implemented - manual merge required", []),
    ok.

-spec write_if_allowed(file:filename(), iolist(), map()) -> ok.
write_if_allowed(File, Content, Opts) ->
    Force = maps:get(force, Opts, false),

    case filelib:is_file(File) andalso not Force of
        true ->
            rebar3_openapi_utils:warn("File exists, skipping (use --force to overwrite): ~s", [File]),
            ok;
        false ->
            rebar3_openapi_utils:write_file(File, Content),
            rebar3_openapi_utils:info("Generated: ~s", [File]),
            ok
    end.

